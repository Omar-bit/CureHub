// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

// User roles enum
enum UserRole {
  DOCTOR
  ASSISTANT
  PATIENT
}

// User model for authentication
model User {
  id                      String    @id @default(cuid())
  email                   String    @unique
  password                String
  role                    UserRole  @default(PATIENT)
  firstName               String?
  lastName                String?
  phone                   String?
  isActive                Boolean   @default(true)
  isEmailVerified         Boolean   @default(false)
  emailVerificationCode   String?
  emailVerificationExpiry DateTime?
  language                String    @default("en")
  createdAt               DateTime  @default(now())
  updatedAt               DateTime  @updatedAt

  // Relations
  doctorProfile DoctorProfile?

  @@map("users")
}

// Doctor profile for professional settings and preferences
model DoctorProfile {
  id     String @id @default(cuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Professional Information
  specialization  String?
  bio             String? @db.Text
  profileImageUrl String?

  // Medical License and Registration (Votre activité)
  rppsNumber          String? @unique // RPPS number
  sirenNumber         String? @unique // SIREN number
  languagesSpoken     String? // JSON array of languages
  diplomas            String? @db.Text // JSON array of diplomas
  additionalDiplomas  String? @db.Text // JSON array of additional diplomas/formations
  publications        String? @db.Text // Publications/research
  signature           String? // Signature (can be text or base64 image)
  absenceMessage      String? @db.Text // Message d'absence
  tooManyAbsencesInfo String? @db.Text // Message "Trop d'absences"

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  clinic               Clinic? // One-to-one relationship with clinic
  patients             Patient[]
  consultationTypes    DoctorConsultationType[]
  timeplans            DoctorTimeplan[]
  appointments         Appointment[]
  tasks                Task[]
  events               Event[]
  documents            PatientDocument[]
  appointmentDocuments AppointmentDocument[]
  appointmentHistory   AppointmentHistory[]
  imprevus             Imprevu[]
  agendaPreferences    AgendaPreferences?
  ptos                 DoctorPTO[]

  @@map("doctor_profiles")
}

// Clinic model for doctor's practice information
model Clinic {
  id              String        @id @default(cuid())
  doctorProfileId String        @unique
  doctorProfile   DoctorProfile @relation(fields: [doctorProfileId], references: [id], onDelete: Cascade)

  // Clinic Information
  name              String? // Full name of the cabinet/clinic
  gender            String? // Gender type (masculine/feminine for French)
  address           String? @db.Text
  address2          String? @db.Text // Second address line
  postalCode        String?
  city              String?
  phone             String?
  prmAccess         Boolean @default(false) // PMR (Personnes à mobilité réduite) accessibility
  videoSurveillance Boolean @default(false) // Video surveillance

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("clinics")
}

// Gender enum for patients
enum Gender {
  MALE
  FEMALE
  OTHER
}

// Consultation location enum
enum ConsultationLocation {
  ONSITE
  ONLINE
  ATHOME
}

// Consultation type enum
enum ConsultationType {
  REGULAR
  URGENT
}

// Relationship type enum for patient relatives
enum RelationshipType {
  FAMILY
  OTHER
}

// Family relationship enum
enum FamilyRelationship {
  SON
  DAUGHTER
  FATHER
  MOTHER
  BROTHER
  SISTER
  SPOUSE
  GRANDFATHER
  GRANDMOTHER
  GRANDSON
  GRANDDAUGHTER
  UNCLE
  AUNT
  NEPHEW
  NIECE
  COUSIN
}

// Patient model managed by doctors
model Patient {
  id           String   @id @default(cuid())
  name         String
  dateOfBirth  DateTime
  profileImage String?
  gender       Gender
  email        String?
  password     String?
  phoneNumber  String?
  address      String?  @db.Text
  isDeleted    Boolean  @default(false)

  // Permissions for patient relatives
  canAddRelatives     Boolean @default(false) // Ajouter des proches
  canBookForRelatives Boolean @default(false) // Prendre RDV pour un proche existant

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  doctorId            String
  doctor              DoctorProfile        @relation(fields: [doctorId], references: [id], onDelete: Cascade)
  appointments        Appointment[] // Keep for backward compatibility (primary patient)
  appointmentPatients AppointmentPatient[] // New many-to-many relation
  taskPatients        TaskPatient[]
  documents           PatientDocument[]

  // Patient relationships (as the main patient)
  relatedPatients        PatientRelationship[] @relation("MainPatient")
  // Relationships where this patient is the related one
  relationshipsAsRelated PatientRelationship[] @relation("RelatedPatient")

  // Disabled consultation types for this patient
  disabledConsultationTypes PatientConsultationTypeAccess[]

  @@map("patients")
}

// Patient Relationship model for linking patients as relatives
model PatientRelationship {
  id               String           @id @default(cuid())
  relationshipType RelationshipType

  // For FAMILY type
  familyRelationship FamilyRelationship?

  // For OTHER type
  customRelationship String? // Custom description for "other" relationships

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations - bidirectional relationship
  mainPatientId String
  mainPatient   Patient @relation("MainPatient", fields: [mainPatientId], references: [id], onDelete: Cascade)

  relatedPatientId String
  relatedPatient   Patient @relation("RelatedPatient", fields: [relatedPatientId], references: [id], onDelete: Cascade)

  @@unique([mainPatientId, relatedPatientId]) // Prevent duplicate relationships
  @@map("patient_relationships")
}

// Consultation Type model for doctors to define their consultation offerings
model DoctorConsultationType {
  id            String               @id @default(cuid())
  name          String
  color         String // Hex color code for UI display
  location      ConsultationLocation
  duration      Int // Duration in minutes
  restAfter     Int // Rest time after consultation in minutes
  type          ConsultationType
  canBookBefore Int // How many minutes before consultation can be booked
  price         Float // Price in the doctor's currency
  enabled       Boolean              @default(true)
  createdAt     DateTime             @default(now())
  updatedAt     DateTime             @updatedAt

  // Relations
  doctorId String
  doctor   DoctorProfile @relation(fields: [doctorId], references: [id], onDelete: Cascade)

  // Timeplan relations
  timeSlotConsultationTypes TimeSlotConsultationType[]
  appointments              Appointment[]

  // Patient access control
  patientAccess PatientConsultationTypeAccess[]

  @@map("doctor_consultation_types")
}

// Enum for days of the week
enum DayOfWeek {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}

// Doctor's weekly timeplan configuration
model DoctorTimeplan {
  id           String        @id @default(cuid())
  doctorId     String
  doctor       DoctorProfile @relation(fields: [doctorId], references: [id], onDelete: Cascade)
  dayOfWeek    DayOfWeek
  specificDate DateTime?     @db.Date // If set, this timeplan is for a specific date only (Calendrier), otherwise it's for the general weekly schedule (Semaine type)
  isActive     Boolean       @default(true) // Allow doctors to temporarily disable a day
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt

  // Relations
  timeSlots DoctorTimeSlot[]

  @@unique([doctorId, dayOfWeek, specificDate]) // One timeplan per doctor per day (or per specific date)
  @@map("doctor_timeplans")
}

// Individual time slots within a day
model DoctorTimeSlot {
  id         String         @id @default(cuid())
  timeplanId String
  timeplan   DoctorTimeplan @relation(fields: [timeplanId], references: [id], onDelete: Cascade)
  startTime  String // Format: "HH:mm" (e.g., "09:00")
  endTime    String // Format: "HH:mm" (e.g., "11:00")
  isActive   Boolean        @default(true)
  createdAt  DateTime       @default(now())
  updatedAt  DateTime       @updatedAt

  // Relations
  consultationTypes TimeSlotConsultationType[]

  @@map("doctor_time_slots")
}

// Junction table for associating consultation types with time slots
model TimeSlotConsultationType {
  id                 String                 @id @default(cuid())
  timeSlotId         String
  timeSlot           DoctorTimeSlot         @relation(fields: [timeSlotId], references: [id], onDelete: Cascade)
  consultationTypeId String
  consultationType   DoctorConsultationType @relation(fields: [consultationTypeId], references: [id], onDelete: Cascade)
  createdAt          DateTime               @default(now())

  @@unique([timeSlotId, consultationTypeId]) // Prevent duplicate associations
  @@map("time_slot_consultation_types")
}

// Appointment status enum
enum AppointmentStatus {
  SCHEDULED
  CONFIRMED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  ABSENT
}

// Task priority enum
enum TaskPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

// Task category enum  
enum TaskCategory {
  RENDEZ_VOUS // Appointments
  DOCUMENTS // Documents
  CONTACTER // Contact
  PAIEMENTS // Payments
  AUTRE // Other
}

// Event type enum
enum EventType {
  JOUR // Full day event
  PLAGE // Time range event
  PONCTUEL // Point in time event
}

// Appointment model for doctor-patient meetings
model Appointment {
  id          String            @id @default(cuid())
  title       String? // Optional appointment title
  description String?           @db.Text // Optional notes or description
  startTime   DateTime // Start date and time of the appointment
  endTime     DateTime // End date and time of the appointment
  status      AppointmentStatus @default(SCHEDULED)
  notes       String?           @db.Text // Doctor's notes about the appointment

  // Relations
  doctorId String
  doctor   DoctorProfile @relation(fields: [doctorId], references: [id], onDelete: Cascade)

  patientId String? // Keep for backward compatibility - primary patient
  patient   Patient? @relation(fields: [patientId], references: [id], onDelete: Cascade)

  appointmentPatients AppointmentPatient[] // Multiple patients support

  consultationTypeId String?
  consultationType   DoctorConsultationType? @relation(fields: [consultationTypeId], references: [id], onDelete: SetNull)

  documents AppointmentDocument[] // Appointment documents
  history   AppointmentHistory[] // Appointment history

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("appointments")
}

// Junction table for appointments with multiple patients
model AppointmentPatient {
  id            String      @id @default(cuid())
  appointmentId String
  appointment   Appointment @relation(fields: [appointmentId], references: [id], onDelete: Cascade)
  patientId     String
  patient       Patient     @relation(fields: [patientId], references: [id], onDelete: Cascade)
  isPrimary     Boolean     @default(false) // Mark the primary patient
  createdAt     DateTime    @default(now())

  @@unique([appointmentId, patientId]) // Prevent duplicate patient assignments
  @@map("appointment_patients")
}

// Task model for doctor task management
model Task {
  id          String       @id @default(cuid())
  title       String
  description String?      @db.Text
  deadline    DateTime? // Optional deadline
  priority    TaskPriority @default(MEDIUM)
  category    TaskCategory @default(AUTRE)
  completed   Boolean      @default(false)
  completedAt DateTime? // When the task was completed

  // Relations
  doctorId     String
  doctor       DoctorProfile @relation(fields: [doctorId], references: [id], onDelete: Cascade)
  taskPatients TaskPatient[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("tasks")
}

model TaskPatient {
  id        String   @id @default(cuid())
  taskId    String
  task      Task     @relation(fields: [taskId], references: [id], onDelete: Cascade)
  patientId String
  patient   Patient  @relation(fields: [patientId], references: [id], onDelete: Cascade)
  createdAt DateTime @default(now())

  @@unique([taskId, patientId])
  @@map("task_patients")
}

// Event model for doctor events management
model Event {
  id                String    @id @default(cuid())
  title             String
  description       String?   @db.Text
  eventType         EventType
  startDate         DateTime
  endDate           DateTime? // For PLAGE type events
  startTime         String? // Format: "HH:mm" for PLAGE and PONCTUEL types
  endTime           String? // Format: "HH:mm" for PLAGE type
  blockAppointments Boolean   @default(false) // Bloquer la prise de RDV
  isRecurring       Boolean   @default(false) // Évènement récurrent
  color             String? // Color for calendar display
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relations
  doctorId String
  doctor   DoctorProfile @relation(fields: [doctorId], references: [id], onDelete: Cascade)

  @@map("events")
}

// Document category enum
enum DocumentCategory {
  PHARMACIE // Pharmacy
  BIOLOGIE // Biology
  RADIOLOGIE // Radiology
  OPTIQUE // Optical
  MATERIEL // Medical equipment
  AUTRE // Other
  COMPTES_RENDUS // Reports
  IMAGERIE // Imaging
  OPERATION // Surgery
  CONSULTATION // Consultation
  HOSPITALISATION // Hospitalization
  SOINS_PARAMEDICAUX // Paramedical care
  KINE // Physiotherapy
  INFIRMIER // Nursing
  PODOLOGUE // Podiatrist
  ORTHOPTISTE // Orthoptist
  ORTHOPHONISTE // Speech therapist
  ADMINISTRATIF // Administrative
  COURRIER // Correspondence
  CERTIFICAT // Certificate
  HONORAIRES // Fees
  CONSENTEMENT // Consent
  ASSURANCE // Insurance
  DEVIS // Estimates
}

// Patient document model
model PatientDocument {
  id           String           @id @default(cuid())
  originalName String // Original filename when uploaded
  fileName     String // Stored filename on server
  filePath     String // File storage path
  fileSize     Int // File size in bytes
  mimeType     String // MIME type (e.g., "application/pdf", "image/jpeg")
  category     DocumentCategory @default(AUTRE)
  description  String? // Optional description
  uploadDate   DateTime         @default(now())
  createdAt    DateTime         @default(now())
  updatedAt    DateTime         @updatedAt

  // Relations
  patientId String
  patient   Patient @relation(fields: [patientId], references: [id], onDelete: Cascade)

  doctorId String
  doctor   DoctorProfile @relation(fields: [doctorId], references: [id], onDelete: Cascade)

  @@map("patient_documents")
}

// Patient consultation type access control
// Tracks which consultation types are disabled for specific patients
model PatientConsultationTypeAccess {
  id                 String   @id @default(cuid())
  patientId          String
  consultationTypeId String
  isEnabled          Boolean  @default(true) // false means disabled for this patient
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  // Relations
  patient          Patient                @relation(fields: [patientId], references: [id], onDelete: Cascade)
  consultationType DoctorConsultationType @relation(fields: [consultationTypeId], references: [id], onDelete: Cascade)

  @@unique([patientId, consultationTypeId]) // One record per patient-consultation type pair
  @@map("patient_consultation_type_access")
}

// Appointment document model
model AppointmentDocument {
  id           String           @id @default(cuid())
  originalName String // Original filename when uploaded
  fileName     String // Stored filename on server
  filePath     String // File storage path
  fileSize     Int // File size in bytes
  mimeType     String // MIME type (e.g., "application/pdf", "image/jpeg")
  category     DocumentCategory @default(AUTRE)
  description  String? // Optional description
  uploadDate   DateTime         @default(now())
  createdAt    DateTime         @default(now())
  updatedAt    DateTime         @updatedAt

  // Relations
  appointmentId String
  appointment   Appointment @relation(fields: [appointmentId], references: [id], onDelete: Cascade)

  doctorId String
  doctor   DoctorProfile @relation(fields: [doctorId], references: [id], onDelete: Cascade)

  @@map("appointment_documents")
}

// Appointment history action types
enum AppointmentHistoryAction {
  CREATED // Appointment created
  UPDATED // Appointment details updated
  STATUS_CHANGED // Status changed
  DOCUMENT_UPLOADED // Document uploaded
  DOCUMENT_DELETED // Document deleted
  RESCHEDULED // Appointment time changed
  PATIENT_ADDED // Patient added to appointment
  PATIENT_REMOVED // Patient removed from appointment
  CONSULTATION_TYPE_CHANGED // Consultation type changed
}

// Appointment history model for tracking all changes
model AppointmentHistory {
  id            String                   @id @default(cuid())
  action        AppointmentHistoryAction
  description   String? // Human-readable description of the change
  changedFields Json? // JSON object with field changes (before/after)
  metadata      Json? // Additional metadata (e.g., document name, old/new values)
  createdAt     DateTime                 @default(now())

  // Relations
  appointmentId String
  appointment   Appointment @relation(fields: [appointmentId], references: [id], onDelete: Cascade)

  doctorId String
  doctor   DoctorProfile @relation(fields: [doctorId], references: [id])

  // If the action was performed by a patient (future feature)
  performedBy String? // User/Patient identifier

  @@map("appointment_history")
}

// Imprevu model for unforeseen events (blocking time periods)
model Imprevu {
  id       String        @id @default(cuid())
  doctorId String
  doctor   DoctorProfile @relation(fields: [doctorId], references: [id], onDelete: Cascade)

  // Time range
  startDate DateTime
  endDate   DateTime

  // Settings
  notifyPatients Boolean @default(true) // Send notifications to patients about cancelled appointments
  blockTimeSlots Boolean @default(true) // Block time slots during this period

  // Message/reason
  reason  String? @db.Text // Reason for the imprevu
  message String? @db.Text // Custom message to send to patients

  // Metadata
  cancelledAppointmentsCount Int      @default(0) // Number of appointments cancelled
  createdAt                  DateTime @default(now())
  updatedAt                  DateTime @updatedAt

  @@index([doctorId])
  @@index([startDate, endDate])
  @@map("imprevus")
}

// School vacation zone enum
enum SchoolVacationZone {
  A
  B
  C
}

// Agenda preferences model for doctor's agenda customization
model AgendaPreferences {
  id                 String             @id @default(cuid())
  doctorProfileId    String             @unique
  doctorProfile      DoctorProfile      @relation(fields: [doctorProfileId], references: [id], onDelete: Cascade)
  mainColor          String             @default("#FFA500") // Hex color code
  startHour          Int                @default(8) // Starting hour (0-23)
  endHour            Int                @default(20) // Ending hour (1-24)
  verticalZoom       Float              @default(1.0) // Zoom level (0.5-3.0)
  schoolVacationZone SchoolVacationZone @default(C)
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt

  @@map("agenda_preferences")
}

// Doctor PTO (Paid Time Off / Congés) model
model DoctorPTO {
  id                String        @id @default(cuid())
  doctorId          String
  doctor            DoctorProfile @relation(fields: [doctorId], references: [id], onDelete: Cascade)
  label             String // Label for the PTO (e.g., "Formation", "Vacance")
  startDate         DateTime      @db.Date // Start date (inclusive)
  endDate           DateTime      @db.Date // End date (inclusive)
  announcements     Int           @default(2) // Number of announcements/reminders
  appointmentsCount Int           @default(0) // Number of appointments affected
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  @@index([doctorId])
  @@index([startDate, endDate])
  @@map("doctor_pto")
}
